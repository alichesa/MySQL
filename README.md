# MySQL
<img width="936" height="428" alt="image" src="https://github.com/user-attachments/assets/13c0f9d4-5d12-47fd-b645-0dd0b186b835" />
<img width="972" height="670" alt="image" src="https://github.com/user-attachments/assets/a19e6959-7d6d-4812-93c5-52131a01dd04" />
- MySQL是基于关系的数据库，通过表格实现，Redis是非关系数据库，主要以视频音频等非关系类型进行存储，通过Key-Value实现。
- 数据库的本质是 增create 删drop 改alter 查show
- 库的本质是文件夹，表的本质是文件
- 数据库的存储方式有很多，但是四种最常用innodb、myisam、memory、blackhole。Innodb支持事务性，行级锁，外键约束等，是5.5后版本主用的存储方式，mysiam只能支持到表锁，并发性没有那么高，是5.5之前的主流。
- innodb偏向于使用自增id作为主键主要是方便查询和管理，如果使用其他的那么使得排序过于随机
- MyISAM是5.5之前的主要存储方法，Innodb是5.5之后的主要存储方法，仅Innodb是支持外键的，MyISAM采用的是索引和数据分离，而Innodb是一起存储的
- 数据库的宽度是数据的显示宽度，而不是存储宽度，存储宽度在指定存储类型的时候就指定了
- float、 double、 decimal 中虽然最后一个最精确，但是它的范围最小，因为其本质实现形式是通过字符串实现的
- varchar的范围是0-65535,且是显示的行总数
- 枚举是单选、集合是多选
- MySQL的内部结构可以分为服务层和存储层，服务层包含连接器，查询缓存，分析器，优化器，执行器等
- SQL语言分为三大类，DDL，DML，DCL，分别为数据语言，管理语言和控制语言
- Drop（DDL）是删除整个表，Delete（DML）是删除部分行，并会记录删除操作在日志里面，方便回滚。Truncate（DDL）是保留表删除所有数据，不可回滚
- DDL是数据定义语言，包含create、drop等。DML是数据管理语言，包含Insert、update、delete。DCL是数据控制语言，
- 脏读，不可重读，幻读都是因为并发程度高引起的问题。隔离程度高，那么并发性就会低
- 脏读--修改了未提交，然后又发生了回滚，读取了本就不存在的数据。不可重读--数据发生了更改，导致第一次和第二次读取结果不同。幻读--也是指读取的结果不同，但更偏向于数据的增加或者删除。丢弃更改--两人同时对同一个数据进行更改，导致其中一个人的更改丢弃
- RR（可重复读）可以防止不可重复读，但是幻读依然存在。RC（读已提交）能防止脏读，RR和RC都是利用了锁实现的。RC利用了共享锁和行级锁，RR利用了行级锁和间隙锁
- MySQL使用的是B+ 树，B+ 树的值最后都是放在叶子节点，这样就使得构造的树更加宽，从而索引更加快，且叶子节点之间会有双向链表，支持范围查询
- MySQL中的事务回滚主要是依靠undo log实现的，所有对事物的修改都会加入到事务回滚日志中，若提交了修改则无法进行回滚
- 共享锁SHARE 是可以让大家一起读，但是无法修改，可以多个共享锁。排他锁UPDATE是不允许其他人进行读写
- 间隙锁是锁定表格间隙，可以防止幻读，除非事务提交结束了否则是不会进行进程的
- 事务性保证了数据的一致性，ACID。MyISAM是不支持事务性。Innodb能够支持到行级锁，而MyISAM只能支持到表级锁
- 锁可以分成三类--总体、类型和粒度，总体就包含乐观锁和悲观锁，类型分为共享锁和排他锁，粒度分为表锁，行锁，页锁，间隙锁，临键锁
- 悲观锁是真锁，乐观锁不是真的上锁，只是会在数据更新的时候进行版本比对
- 视图是虚拟的表，视图本身就是一个存储的查询，视图可以将复杂的查询简化
- 索引查询和非索引查询本质就是在于是否是主键索引，如果是主键索引，那么就可以查询出所有的，但是如果不是主键那就回查询到主键再回表
- 数据库的索引应该建立在最频繁使用的、用以缩小查询范围的字段上，索引会加大内存损耗
- 第一范式--字段不可分，体现原子性。第二范式--有主键，非主键依赖主键，体现唯一性。第三范式--非主键不能相互依赖，每列有与主键存在关系，不存在传递依赖
- 原子性--事务要么全部成功要么全部回滚。一致性--事务发生后，数据库完整性不会遭到破坏。隔离性--多并发时，多个事务之间相互隔离。 持久性--事务一旦提交那就是永久改变
- vchar是存多少就是多少，存取慢。char是固定长度，不够就空格补齐，存取快
- 想要实现行锁，则必须加上索引，否则就是表锁
- B树的存储是分散的，因此对于磁盘的IO就是多次，因为磁盘的基础单位是页，而B+树是连续存储，因此IO较少
- 虽然哈希比B+快，但是由于哈希只是单个值，而B+树可以有连续存储，因此B+ 是不二之选
- 原子性是通过undo log 实现的。 持久性是通过redo log实现的，redo log会写入磁盘
- MyISAM在使用insert的时候会添加表锁
- 在 MySQL 中，死锁通常发生在 InnoDB 存储引擎使用 行级锁 或 表级锁 时，特别是在事务并发执行时。如果两个事务需要相同的资源，但持有了彼此所需的资源，就可能发生死锁。
- InnoDB 存储引擎会定期检查系统中的事务是否存在死锁。如果检测到死锁，它会选择一个事务作为牺牲者，回滚该事务，使其他事务能够继续执行。
